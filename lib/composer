#!/usr/bin/env bash
#

function get_php_version() {
    # Prints out the PHP version (major.minor)

    php -v \
        | head -n 1 \
        | cut -d " " -f 2 \
        | cut -f 1-2 -d "."
}

function version_is_ge() {
    # Checks if the given version is greater or equal than the one required
    # $1: version to check
    # $2: required version

    local rc=1

    if { echo "${1}"; echo "${2}"; } | sort --reverse --version-sort --check 2> /dev/null
    then
        rc=0
    fi

    return "${rc}"
}

function check_composer_syntax() {
  local target="$1"

  if [ -f "$target/composer.json" ]; then
      [ -z "$(cat "$target/composer.json")" ] && \
        error "composer.json is empty, remove it from GIT repository or fill its content."
      jq . < "$target/composer.json" >/dev/null 2>&1 || error "composer.json is not a valid JSON file."
  fi

  if [ -f "$target/composer.lock" ]; then
      [ -z "$(cat "$target/composer.lock")" ] && \
        error "composer.lock is empty, generate it with the composer command."
      jq . < "$target/composer.lock" >/dev/null 2>&1 || error "composer.lock is not a valid JSON file."
  fi
}

function check_composer_json_and_lock() {
  local target="$1"

  if [ ! -f "$target/composer.json" ]; then
      return 0
  fi

  if [ ! -f "$target/composer.lock" ]; then
      error "composer.lock has not been found, please lock the dependencies of your project."
  fi
}

php::extension::is_embedded() {

	local extension_name="${1}"

	local rc=1
	local result="false"
	local php_modules

	if php_modules="$( php --modules 2>&1 )"; then
		rc=0

		if grep --quiet --extended-regexp --ignore-case "^${extension_name}$" \
			<<< "${php_modules}"
		then
			result="true"
		fi
	fi

	echo "${result}"
	exit "${rc}"
}

php::composer::install() {

	local build_dir="${1}"
	local cache_dir="${2}"
	local php_url="${3}"

	# FIXME: provide a default version
	local version="${COMPOSER_VERSION:-"${COMPOSER_DEFAULT_VERSION}"}"

	local archive="composer-${version}.phar"

	local file_url="${php_url}/composer/${archive}"
	local hash_url="${file_url}.md5"

	local cache_file="${cache_dir:?}/${archive}"
	local hash_file="${cache_file}.md5"

	local target_dir="${build_dir}/vendor/composer/bin"


	cmn::step::start "Installing Composer ${version}"
	
	cmn::task::start "Downloading checksum"
	# Remove previous hash file:
	rm --recursive --force "${cache_dir:?}"/*.phar.md5

	if ! cmn::file::download "${hash_url}" "${hash_file}"; then
		cmn::task::fail
		cmn::step::fail
		exit 200
	fi
	cmn::task::finish

	if [ ! -f "${cache_file}" ]; then
	# Remove archive from cache, since they are probably for another version:
		cmn::task::start "Cleaning cache"
		rm --recursive --force "${cache_dir:?}"/*.phar
		cmn::task::finish

		# Download appropriate version:
		cmn::task::start "Downloading archive"
		if ! cmn::file::download "${file_url}" "${cache_file}"; then
			cmn::task::fail
			cmn::step::fail
			exit 201
		fi
		cmn::task::finish
	else
		cmn::output::info "Found matching file in cache."
	fi

	cmn::task::start "Checking archive validity"
	if ! cmn::file::check_checksum "${cache_file}" "${hash_file}"; then
		cmn::task::fail
		cmn::output::err <<- EOM
			Unable to check archive validity.
			I'm now removing the file from the cache to force
			a new download during the next deployment attempt.
		EOM

		# File in cache does not seem valid,
		# remove it so a future run can be successful
		rm --force "${cache_file}"
		rm --force "${hash_file}"
		cmn::step::fail
		exit 202
	fi
	cmn::task::finish

	# From this point we have a valid file in cache.

	cmn::task::start "Vendoring Composer"
	if ! mkdir --parents "${target_dir}" 2>/dev/null
	then
		cmn::task::fail
		cmn::step::fail
		exit 203
	fi

	if ! cp "${cache_file}" "${target_dir}/composer.phar" 2>/dev/null
	then
		cmn::task::fail
		cmn::step::fail
		cmn::output::debug <<- EOM
			Failed to copy
			  from: ${cache_file}
			    to: ${target_dir}
		EOM
		exit 204
	fi
	cmn::task::finish

	cmn::task::start "Setting permissions"
	if ! chmod a+x "${target_dir}/composer.phar" 2>/dev/null
	then
		cmn::task::fail
		cmn::step::fail
		exit 205
	fi
	cmn::task::finish

	cmn::task::start "Creating symlinks"
	for link in "${target}/bin/composer" "${target}/bin/composer.phar"
	do
		if ln --symbolic --force --no-dereference \
			"${target_dir}/composer.phar" "${link}" 2>/dev/null
		then
			cmn::task::fail
			cmn::step::fail
			exit 206
		fi
	done
	cmn::task::finish

	cmn::step::finish
}

php::composer::install_dependency() {
	local build_dir="${1}"
	local cache_dir="${2}"
	local ext_name="${3}"

	local ext
	local version

	
	# First convert extension name to lowercase:
	ext="$( tr "[:upper:]" "[:lower:]" <<< "${ext_name}" )"

	cmn::task::start "Installing extension ${ext}"
	if ! version="$( jq --raw-output ".require | .[\"ext-${ext}\"]" \
		< "${build_dir}/composer.json" \
		)"
	then
		cmn::task::fail
		cmn::output::error <<- EOM
			Unable to retrieve the desired version of extension ${ext}.
			Is your composer.json file valid?
		EOM
		exit 320
	fi

	cmn::output::debug "Installing ${ext} ${version}"

	if ! is_embbeded="$( php::extension::is_embedded "${ext}" )"; then
		cmn::task::fail
		cmn::output::err <<- EOM
			Unable to check whether ${ext} is already embedded or not.
			Aborting.
		EOM
		exit 321
	fi

	if [[ "${is_embedded}" == "true" ]]; then
		cmn::output::info <<- EOM
			PHP extension ${ext} is already embedded in runtime. Skipping.
		EOM
		exit 0
	fi

	# Install pre-requisites, if any:
	if [ -f "${buildpack_dir}/lib/extensions/${ext}" ]; then
		source "${buildpack_dir}/lib/extensions/${ext}"
	fi

	# The Zend OPCache extension is a bit special:
	# It's listed by `php --modules` as `Zend OPCache`, but we must
	# refer to it as `zend-opcache` in `composer.json`.
	# Consequently, we have to detect it and rename it for the
	# buildpack logic to work.

	if [ "${ext}" = "zend-opcache" ]; then
		ext="zend opcache"
	fi

	#if [ -n "$apt_deps" ] ; then
	#  echo "Installing dependencies for ${ext}: ${apt_deps}" | indent
	#  install_env_file="$(apt_install "${apt_deps}" "${BUILD_DIR}" "${CACHE_DIR}" "${ENV_DIR}")"
	# Source environment to export LD_LIBRARY_PATH
	#  source "${install_env_file}"
	#  rm "${install_env_file}"
	#fi

            # Install third-party dependencies after ubuntu packages have been added
            if [ "$ext" = "memcached" ] ; then
              fetch_package "$PHP_BASE_URL" "libmemcached-${libmemcached_version}" "/app/vendor/libmemcached" | indent
            elif [ "$ext" = "gmp" ] ; then
              fetch_package "$PHP_BASE_URL" "gmp-${gmp_version}" "/app/vendor/gmp" | indent
            elif [ "$ext" = "tidy" ] ; then
              fetch_package "$PHP_BASE_URL" "libtidy-${tidy_version}" "/app/vendor/libtidy" | indent
            elif [ "$ext" = "sodium" ] ; then
              if [[ "$(php_api_version)" -lt "${PHP_MODULE_API_VERSIONS["7.4"]}" ]] ; then
                sodium_version=$sodium_php72_php73_version
              fi
              fetch_package "$PHP_BASE_URL" "libsodium-${sodium_version}" "/app/vendor/libsodium" | indent
            fi

            local extension_package_path="ext/$(php_api_version)/php-${ext}"
            package_found="$(has_package "${PHP_BASE_URL}" "${extension_package_path}")"
            if [ "${package_found}" = "true" ] ; then
              echo "Installing PHP extension: ${ext}" | indent
              fetch_package "${PHP_BASE_URL}" "${extension_package_path}" "/app/vendor/php"
            else
              install_pecl_extension "${ext}" "${ext_version}" "${CACHE_DIR}"
            fi


}

php::composer::install_dependencies() {

	local build_dir="${1}"
	local cache_dir="${2}"
	local php_base_url="${3}"

	local cwd="$( pwd )"

	COMPOSER_CACHE_DIR="${cache_dir}/composer"
	export COMPOSER_CACHE_DIR

	mkdir --parents "${COMPOSER_CACHE_DIR}"


	cmn::step::start "Installing dependencies"

	cmn::task::start "Checking dependencies"
	local required_extensions

	if ! required_extensions="$( jq --raw-output '.require // {} | keys | .[]' \
			< "${build_dir}/composer.json" \
			| grep "^ext-" \
			| sed "s/^ext-//" \
		)"
	then
		cmn::task::fail
		cmn::output::err <<- EOM
			Unable to retrieve the list of required extensions.
			Please make sur your composer.json file is well-formatted.
			Aborting.
		EOM
		cmn::step::fail
		exit 210
	fi
	cmn::task::finish
	cmn::step::finish

	if [ -n "${required_extensions}" ]; then
		cmn::step::start "Bundling dependencies"

		# /!\ Not quoting required_extensions on purpose
		for ext in ${required_extensions}; do
			php::composer::install_dependency \
				"${build_dir}" "${cache_dir}" "${ext}"
		done
	fi

### FIXME:

    if [ -n "$COMPOSER_GITHUB_TOKEN" ]; then
        status "Configuring the GitHub authentication for Composer"
        php "vendor/composer/bin/composer.phar" config -g github-oauth.github.com "$COMPOSER_GITHUB_TOKEN" --no-interaction
    fi

    status "Installing application dependencies with Composer"
    {
        local devopt="--no-dev"
        local dev=${COMPOSER_DEV:=false}
        [ "x$dev" = "xtrue" ] && devopt="--dev"

        cd "$target"
        php "vendor/composer/bin/composer.phar" install \
            --prefer-dist \
            --optimize-autoloader \
            --no-interaction \
            $devopt
        cd "$cwd"
    } | indent
}
